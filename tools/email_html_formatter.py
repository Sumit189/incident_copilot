"""
HTML email formatter for Incident CoPilot emails.
Converts plain text incident reports to professional HTML emails with inline CSS.
"""

from typing import Optional
import re


def format_incident_email_html(plain_text_body: str, pr_url: Optional[str] = None, pr_number: Optional[int] = None) -> str:
    """
    Convert plain text incident report to professional HTML email.
    
    Args:
        plain_text_body: Plain text email body
        pr_url: Optional PR URL to include
        pr_number: Optional PR number
    
    Returns:
        HTML formatted email with inline CSS
    """
    html_template = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incident Report</title>
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f5f5f5; line-height: 1.6; color: #333333;">
    <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="100%" style="background-color: #f5f5f5;">
        <tr>
            <td style="padding: 20px 0;">
                <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="600" style="margin: 0 auto; background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Header -->
                    <tr>
                        <td style="background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); padding: 30px; border-radius: 8px 8px 0 0;">
                            <h1 style="margin: 0; color: #ffffff; font-size: 24px; font-weight: 600; letter-spacing: 0.5px;">INCIDENT REPORT</h1>
                        </td>
                    </tr>
                    
                    <!-- Content -->
                    <tr>
                        <td style="padding: 30px;">
                            {content}
                        </td>
                    </tr>
                    
                    <!-- Footer -->
                    <tr>
                        <td style="background-color: #f8f9fa; padding: 20px 30px; border-top: 1px solid #e9ecef; border-radius: 0 0 8px 8px; text-align: center; color: #6c757d; font-size: 12px;">
                            <p style="margin: 0;">Auto-generated by Incident CoPilot</p>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</body>
</html>"""
    
    sections = _parse_structured_sections(plain_text_body)
    if sections:
        body_html = _render_structured_sections(sections, pr_url, pr_number)
    else:
        body_html = _convert_plain_text_to_html(plain_text_body)
        if pr_url:
            body_html += _format_pr_section(pr_url, pr_number)
    
    if not body_html.strip():
        body_html = '<div style="color: #495057; line-height: 1.7;">' + '<br>'.join(
            [_format_rich_text(line) for line in plain_text_body.split('\n') if line.strip()]
        ) + '</div>'
    
    return html_template.format(content=body_html)


def _convert_plain_text_to_html(plain_text_body: str) -> str:
    """Convert plain text to a simple HTML structure while preserving sections."""
    lines = plain_text_body.splitlines()
    html_parts = []
    block: list[str] = []
    
    def flush_block():
        nonlocal block
        if not block:
            return
        html_parts.append(_format_block(block))
        block = []
    
    for line in lines:
        if line.strip():
            block.append(line.rstrip())
        else:
            flush_block()
    
    flush_block()
    return '\n'.join(html_parts)


def _parse_structured_sections(plain_text_body: str) -> list[tuple[str, str]]:
    """Detect labeled sections (e.g., INCIDENT SUMMARY — ...) and preserve their order."""
    pattern = re.compile(r'^([A-Z0-9][A-Z0-9 \\/&_-]+)\s+[—–-]\s*(.*)$')
    sections: list[tuple[str, str]] = []
    current_title: Optional[str] = None
    buffer: list[str] = []

    def flush_section():
        nonlocal buffer, current_title
        if current_title is None:
            return
        content = '\n'.join(buffer).strip()
        if content:
            sections.append((current_title.strip(), content))
        buffer = []

    for raw_line in plain_text_body.splitlines():
        line = raw_line.strip()
        heading = pattern.match(line)
        if heading:
            flush_section()
            current_title = heading.group(1).strip()
            remainder = heading.group(2).strip()
            buffer = [remainder] if remainder else []
        else:
            if current_title:
                buffer.append(raw_line)

    flush_section()
    return sections


def _render_structured_sections(
    sections: list[tuple[str, str]],
    pr_url: Optional[str],
    pr_number: Optional[int]
) -> str:
    """Render detected sections with dedicated layouts."""
    html_parts: list[str] = []
    pending_pr_url = pr_url

    for title, content in sections:
        normalized = title.upper().strip()

        if normalized == "INCIDENT SUMMARY":
            html_parts.append(_render_incident_summary(content))
        elif normalized == "ROOT CAUSE":
            html_parts.append(_wrap_section("Root Cause", _render_paragraphs(content)))
        elif normalized == "SOLUTION STATUS":
            html_parts.append(_render_solution_status(content))
        elif normalized == "ACTION PLAN":
            html_parts.append(_render_action_plan(content))
        elif normalized == "PULL REQUEST":
            pr_section = _render_pull_request_section(content, pending_pr_url, pr_number)
            if pr_section:
                html_parts.append(pr_section)
            pending_pr_url = None
        else:
            html_parts.append(_wrap_section(title.title(), _render_paragraphs(content)))

    if pending_pr_url:
        html_parts.append(_format_pr_section(pending_pr_url, pr_number))

    return ''.join(html_parts)


def _wrap_section(title: str, inner_html: str) -> str:
    return f"""
    <section style="margin-bottom: 24px; padding: 20px; border: 1px solid #e9ecef; border-radius: 10px; background-color: #ffffff;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
            <h2 style="margin: 0; font-size: 16px; letter-spacing: 0.5px; text-transform: uppercase; color: #2c3e50;">{_escape_html(title)}</h2>
        </div>
        {inner_html}
    </section>
    """


def _render_incident_summary(content: str) -> str:
    pairs, extras = _extract_key_value_data(content)
    rows_html = ''.join(format_key_value_pair(key.strip().rstrip('.'), value) for key, value in pairs)
    table_html = f'<table style="width: 100%; border-collapse: collapse;">{rows_html}</table>' if rows_html else ''
    extra_html = ''.join(
        f'<p style="margin: 0 0 10px 0; color: #495057; line-height: 1.6;">{_format_rich_text(text)}</p>'
        for text in extras
    )
    return _wrap_section("Incident Summary", table_html + extra_html)


def _extract_key_value_data(content: str) -> tuple[list[tuple[str, str]], list[str]]:
    tokens = re.split(r'(?:,|\n)', content)
    pairs: list[tuple[str, str]] = []
    leftovers: list[str] = []

    for token in tokens:
        segment = token.strip()
        if not segment:
            continue
        if ':' in segment:
            key, value = segment.split(':', 1)
            pairs.append((key.strip(), value.strip()))
        else:
            leftovers.append(segment)

    return pairs, leftovers


def _render_paragraphs(content: str) -> str:
    paragraphs = [line.strip() for line in content.splitlines() if line.strip()]
    if not paragraphs and content.strip():
        paragraphs = [content.strip()]

    return ''.join(
        f'<p style="margin: 0 0 12px 0; color: #495057; line-height: 1.7;">{_format_rich_text(text)}</p>'
        for text in paragraphs
    )


def _render_solution_status(content: str) -> str:
    inner = f"""
    <div style="padding: 16px; border-left: 4px solid #2c3e50; background-color: #f8f9fa; border-radius: 6px;">
        {_render_paragraphs(content)}
    </div>
    """
    return _wrap_section("Solution Status", inner)


def _render_action_plan(content: str) -> str:
    numbered_items = _extract_numbered_items(content)
    bullet_items = numbered_items or _extract_bullet_items(content)

    if bullet_items:
        items_html = ''.join(
            f'<li style="margin-bottom: 8px;">{_format_rich_text(item)}</li>'
            for item in bullet_items
        )
        return _wrap_section(
            "Action Plan",
            f'<ol style="padding-left: 20px; margin: 0; color: #495057;">{items_html}</ol>'
        )

    return _wrap_section("Action Plan", _render_paragraphs(content))


def _extract_numbered_items(content: str) -> list[str]:
    matches = re.findall(r'\d+[\.\)]\s*(.*?)(?=(?:\d+[\.\)]\s)|$)', content, flags=re.S)
    items = [re.sub(r'\s+', ' ', match).strip() for match in matches if match.strip()]
    return items


def _extract_bullet_items(content: str) -> list[str]:
    items: list[str] = []
    for line in content.splitlines():
        stripped = line.strip()
        if stripped.startswith(('- ', '* ')):
            items.append(stripped[2:].strip())
        elif stripped:
            items.append(stripped)
    return items


def _render_pull_request_section(content: str, pr_url: Optional[str], pr_number: Optional[int]) -> str:
    detected_url = pr_url or _find_first_url(content)
    detected_number = pr_number or _find_pr_number(content)
    description = content

    if detected_url and detected_url in description:
        description = description.replace(detected_url, '').strip()

    description = description.strip(':- ').strip()

    if detected_url:
        return _format_pr_section(detected_url, detected_number, description or None)

    if description:
        return _wrap_section("Pull Request", _render_paragraphs(description))

    return ""


def _find_pr_number(content: str) -> Optional[int]:
    match = re.search(r'#(\d+)', content)
    if match:
        try:
            return int(match.group(1))
        except ValueError:
            return None
    return None


def _find_first_url(content: str) -> Optional[str]:
    match = re.search(r'https?://[^\s)]+', content)
    return match.group(0) if match else None


def _format_block(block: list[str]) -> str:
    """Format a block of text into headings, lists, or paragraphs."""
    if not block:
        return ""
    
    # Heading: single line, mostly uppercase
    if len(block) == 1:
        candidate = block[0].strip()
        stripped = candidate.replace('-', '').replace('=', '').strip()
        if stripped and stripped == stripped.upper() and len(stripped) > 3:
            return f'<h2 style="color: #2c3e50; font-size: 18px; font-weight: 600; margin: 30px 0 15px 0; padding-bottom: 10px; border-bottom: 2px solid #e9ecef;">{_format_rich_text(candidate.title())}</h2>'
    
    # List detection (numbered or dashed)
    list_items = []
    is_list = True
    for line in block:
        stripped = line.strip()
        if stripped[:2] in ("- ", "* "):
            list_items.append(stripped[2:].strip())
        elif stripped[:3].isdigit() and ". " in stripped[:5]:
            list_items.append(stripped.split(". ", 1)[1])
        else:
            is_list = False
            break
    
    if is_list and list_items:
        items_html = ''.join(
            f'<li style="margin-bottom: 8px; line-height: 1.6;">{_format_rich_text(item)}</li>'
            for item in list_items
        )
        return f'<ul style="margin: 0 0 20px 0; padding-left: 25px; color: #495057;">{items_html}</ul>'
    
    # Paragraph block
    paragraph = ' '.join(s.strip() for s in block if s.strip())
    return f'<p style="margin: 0 0 15px 0; color: #495057; line-height: 1.7;">{_format_rich_text(paragraph)}</p>'


def _format_section(title: Optional[str], content: list, is_list: bool) -> str:
    """Format a section with title and content."""
    html = []
    
    if title:
        html.append(f'<h2 style="color: #2c3e50; font-size: 18px; font-weight: 600; margin: 30px 0 15px 0; padding-bottom: 10px; border-bottom: 2px solid #e9ecef;">{title}</h2>')
    
    if is_list:
        html.append('<ul style="margin: 0 0 20px 0; padding-left: 25px; color: #495057;">')
        for item in content:
            html.append(f'<li style="margin-bottom: 8px; line-height: 1.6;">{_format_rich_text(item)}</li>')
        html.append('</ul>')
    else:
        for para in content:
            if para.strip():
                html.append(f'<p style="margin: 0 0 15px 0; color: #495057; line-height: 1.7;">{_format_rich_text(para)}</p>')
    
    return '\n'.join(html)


def _format_pr_section(pr_url: str, pr_number: Optional[int] = None, description: Optional[str] = None) -> str:
    """Format PR section with styled button."""
    pr_text = f"PR #{pr_number}" if pr_number else "Pull Request"
    details = description or "A pull request has been created for this incident. Please review the changes, ensure CI passes, and merge when ready."
    
    return f"""
    <div style="margin: 30px 0; padding: 20px; background-color: #f8f9fa; border-left: 4px solid #2c3e50; border-radius: 4px;">
        <h3 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px; font-weight: 600;">Pull Request</h3>
        <p style="margin: 0 0 15px 0; color: #495057; line-height: 1.6;">
            {_format_rich_text(details)}
        </p>
        <table role="presentation" cellspacing="0" cellpadding="0" border="0">
            <tr>
                <td style="background-color: #2c3e50; border-radius: 4px; padding: 12px 24px;">
                    <a href="{pr_url}" style="color: #ffffff; text-decoration: none; font-weight: 600; font-size: 14px; display: inline-block;">
                        View {pr_text}
                    </a>
                </td>
            </tr>
        </table>
        <p style="margin: 15px 0 0 0; color: #6c757d; font-size: 12px;">
            Code changes and diff are available in the PR.
        </p>
    </div>
    """


def _format_rich_text(text: str) -> str:
    """Escape HTML and apply markdown formatting."""
    escaped = _escape_html(text)
    return _apply_markdown(escaped)


def _apply_markdown(text: str) -> str:
    """Convert simple markdown markers to HTML with inline styles."""
    # Bold: **text** -> <strong>
    text = re.sub(r'\*\*(.*?)\*\*', r'<strong style="color: #2c3e50; font-weight: 700;">\1</strong>', text)
    
    # Italic: *text* -> <em>
    text = re.sub(r'\*(.*?)\*', r'<em style="color: #495057; font-style: italic;">\1</em>', text)
    
    # Code: `text` -> <code>
    text = re.sub(r'`(.*?)`', r'<code style="background-color: #e9ecef; padding: 2px 5px; border-radius: 3px; font-family: SFMono-Regular, Consolas, \'Liberation Mono\', Menlo, monospace; font-size: 0.9em; color: #d63384;">\1</code>', text)
    
    return text


def _escape_html(text: str) -> str:
    """Escape HTML special characters."""
    return (text
            .replace('&', '&amp;')
            .replace('<', '&lt;')
            .replace('>', '&gt;')
            .replace('"', '&quot;')
            .replace("'", '&#39;'))


def format_key_value_pair(key: str, value: str) -> str:
    """Format a key-value pair in a table row."""
    return f"""
    <tr>
        <td style="padding: 8px 0; color: #6c757d; font-weight: 600; width: 150px; vertical-align: top;">{key}:</td>
        <td style="padding: 8px 0; color: #495057;">{_format_rich_text(value)}</td>
    </tr>
    """

